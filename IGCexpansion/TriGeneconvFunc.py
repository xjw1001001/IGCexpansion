# This file is especially made for rate matrix construction which is the core of the project
# Sept. 14, 2015
# Xiang Ji

import numpy as np
import numpy as np
import networkx as nx
import scipy
import scipy.optimize
import scipy.sparse
import scipy.sparse.linalg
import os
from copy import deepcopy

from operator import mul
from itertools import product
from functools import partial

from Bio import Phylo
from Bio import SeqIO

import jsonctmctree.ll, jsonctmctree.interface

def get_HKYBasic(pi, kappa, prior_distribution):
    Qbasic = np.array([
        [0, 1.0, kappa, 1.0],
        [1.0, 0, 1.0, kappa],
        [kappa, 1.0, 0, 1.0],
        [1.0, kappa, 1.0, 0],
        ]) * np.array(pi)
    expected_rate = np.dot(prior_distribution, Qbasic.sum(axis = 1))
    Qbasic = Qbasic / expected_rate
    return Qbasic

def get_HKYGeneconv(pi, kappa, prior_distribution, nt_to_state, tau, oldest_paralog_num):
    # oldest_paralog_num is a number in [0, 1, 2]
    #print 'tau = ', self.tau
    Qbasic = get_HKYBasic(pi, kappa, prior_distribution)
    two_paralog_list = [i for i in range(3) if i != oldest_paralog_num]
    row_pre_1st_dup = []
    col_pre_1st_dup = []
    row_pre_2nd_dup = []
    col_pre_2nd_dup = []
    row_post_2nd_dup = []
    col_post_2nd_dup = []
    rate_pre_1st_dup = []
    rate_pre_2nd_dup = []
    rate_post_2nd_dup = []
    

    for i, triple_from in enumerate(product('ACGT', repeat = 3)):
        na, nb, nc = triple_from
        sa = nt_to_state[na]
        sb = nt_to_state[nb]
        sc = nt_to_state[nc]
        for j, triple_to in enumerate(product('ACGT', repeat = 3)):
            nd, ne, nf = triple_to
            sd = nt_to_state[nd]
            se = nt_to_state[ne]
            sf = nt_to_state[nf]
            if i == j:
                continue
            GeneconvRate = get_HKYGeneconvRate(triple_from, triple_to, Qbasic, tau)
            if GeneconvRate != 0.0:
                row_post_2nd_dup.append((sa, sb, sc))
                col_post_2nd_dup.append((sd, se, sf))
                rate_post_2nd_dup.append(GeneconvRate)

            IGCrate_pre_2nd_dup = get_HKYGeneconvRate(triple_from, triple_to, Qbasic, tau, two_paralog_list)
            if IGCrate_pre_2nd_dup != 0.0:
                row_pre_2nd_dup.append((sa, sb, sc))
                col_pre_2nd_dup.append((sd, se, sf))
                rate_pre_2nd_dup.append(IGCrate_pre_2nd_dup)

            IGCrate_pre_1st_dup = get_HKYGeneconvRate(triple_from, triple_to, Qbasic, tau, [oldest_paralog_num])
            if IGCrate_pre_1st_dup != 0.0:
                row_pre_1st_dup.append((sa, sb, sc))
                col_pre_1st_dup.append((sd, se, sf))
                rate_pre_1st_dup.append(IGCrate_pre_1st_dup)            

    process_pre_1st_dup = dict(
        row = row_pre_1st_dup,
        col = col_pre_1st_dup,
        rate = rate_pre_1st_dup
        )
    process_pre_2nd_dup = dict(
        row = row_pre_2nd_dup,
        col = col_pre_2nd_dup,
        rate = rate_pre_2nd_dup
        )
    process_post_2nd_dup = dict(
        row = row_post_2nd_dup,
        col = col_post_2nd_dup,
        rate = rate_post_2nd_dup
        )

    return [process_pre_1st_dup, process_pre_2nd_dup, process_post_2nd_dup]

#def get_GC_fitness(

def get_HKYGeneconvRate(triple_from, triple_to, Qbasic, tau, paralog = [0, 1, 2]):
    # paralog is a list for existing paralogs
    # tau is 8 element list
    # 1 -> 2, 1 -> 3, 2 -> 3, 2 -> 1, 3 -> 1, 3 -> 2, oldest -> dup, dup -> oldest
    
    na, nb, nc = triple_from
    nd, ne, nf = triple_to
    if len(paralog) == 3:
        if diff(triple_from, triple_to) == 1:
            if na != nd:  # na -> nd
                Qb = Qbasic['ACGT'.index(na), 'ACGT'.index(nd)]
                if nd == nb:
                    Qb += tau[3]  # add tau21
                if nd == nc:
                    Qb += tau[4]  # add tau31
                return Qb
            elif nb != ne:  # nb -> ne
                Qb = Qbasic['ACGT'.index(nb), 'ACGT'.index(ne)]
                if ne == na:
                    Qb += tau[0]  # add tau12
                if ne == nc:
                    Qb += tau[5]  # add tau32
                return Qb
            elif nc != nf:  # nc -> nf
                Qb = Qbasic['ACGT'.index(nc), 'ACGT'.index(nf)]
                if nf == na:
                    Qb += tau[1]  # add tau13
                if nf == nb:
                    Qb += tau[2]  # add tau23
                return Qb
            else:
                print 'Must be something wrong, check get_HKYGENEconvRate'
                return None
        else:
            return 0.0
    elif len(paralog) == 2:
        # post 1st duplication pre 2nd duplication
        # paralog contains the two copies generated by 2nd duplication
        if triple_from[paralog[0]] != triple_from[paralog[1]] or triple_to[paralog[0]] != triple_to[paralog[1]]:
            return 0.0
        elif diff(triple_from, triple_to) == 3:
            return 0.0
        elif diff(triple_from, triple_to) == 2:
            # the identical states transit
            Qb = Qbasic['ACGT'.index(triple_from[paralog[0]]), 'ACGT'.index(triple_to[paralog[0]])]
            if triple_to[0] == triple_to[1] == triple_to[2]:  # copy to the identical state
                ind = [i for i in range(3) if not i in paralog][0]
                #Qb += sum(tau[2*i : 2*(i+1)]) / 2.0  # add average tau for now
                Qb += tau[-1]  # dup -> oldest
            return Qb
        elif diff(triple_from, triple_to) == 1:
            # the one paralog got transition
            ind = [i for i in range(3) if not i in paralog][0]
            Qb = Qbasic['ACGT'.index(triple_from[ind]), 'ACGT'.index(triple_to[ind])]
            if triple_to[0] == triple_to[1] == triple_to[2]:
                Qb += tau[-2]  # oldest -> dup
            return Qb
    elif len(paralog) == 1:
        if triple_from[0] == triple_from[1] == triple_from[2] and triple_to[0] == triple_to[1] == triple_to[2]:
            return Qbasic['ACGT'.index(triple_from[0]), 'ACGT'.index(triple_to[0])]
        else:
            return 0.0
    else:
        print 'check input paralog list plz'
        assert(0 == 1)
 
def diff(triple_from, triple_to):
    na, nb, nc = triple_from
    nd, ne, nf = triple_to
    return sum([na != nd, nb != ne, nc != nf])


